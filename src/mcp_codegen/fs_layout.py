"""Generate per-tool Python files in browsable folder tree.

This implements the progressive disclosure pattern from Anthropic's guidance.
Each tool becomes its own file, enabling just-in-time loading.
"""
from __future__ import annotations
from typing import List
import os
import re
import keyword
from pathlib import Path
from .codegen import _pydantic_model_for_params, _py_name

def generate_fs_layout(
    base_url: str,
    module_name: str,
    tools,
    output_dir: str = "servers"
) -> None:
    """Generate per-tool Python files in filesystem layout.

    Args:
        base_url: MCP server base URL
        module_name: Server name (used as folder name)
        tools: List of tool definitions from MCP server
        output_dir: Base output directory (default: "servers")

    Creates:
        servers/<module_name>/
            __init__.py          # Server index with metadata
            <tool_name>.py       # Individual tool files
    """
    # Get actual protocol version from tools (negotiated during fetch_schema)
    # This ensures generated files have the correct version
    actual_protocol_version = getattr(tools[0], 'protocol_version', '2025-06-18') if tools else '2025-06-18'

    # Track used identifiers to prevent collisions
    used_identifiers: set[str] = set()

    def _safe_identifier(name: str, is_class: bool = False) -> str:
        """Generate safe Python identifier, handling collisions.

        Args:
            name: Original name (e.g., "create-pr", "list_files")
            is_class: If True, return CamelCase; otherwise snake_case

        Returns:
            Safe, unique identifier
        """
        # Convert to snake_case: replace hyphens/spaces with underscores
        safe = re.sub(r'[-\s]+', '_', name.strip().lower())

        # Remove invalid characters
        safe = re.sub(r'[^a-zA-Z0-9_]', '', safe)

        # Handle leading digits
        if safe and safe[0].isdigit():
            safe = f"tool_{safe}"
        elif not safe:
            safe = "tool"

        # Handle Python keywords
        if keyword.iskeyword(safe):
            safe = f"{safe}_"

        # Check for collisions in exports
        base = safe
        counter = 1
        while safe in used_identifiers:
            safe = f"{base}_{counter}"
            counter += 1

        used_identifiers.add(safe)
        return safe

    # Create server directory
    server_dir = Path(output_dir) / module_name
    server_dir.mkdir(parents=True, exist_ok=True)

    # Generate individual tool files
    tool_info = []  # Collect for __init__.py
    for tool in tools:
        # Use safe identifier to prevent collisions
        tool_name = _safe_identifier(tool.name, is_class=False)
        original_name = tool.name

        # Generate model code
        model_code = _pydantic_model_for_params(tool)

        # Generate tool file content
        tool_file_content = f'''"""Tool: {original_name}

Generated by: mcp-codegen v2
Source: {base_url}
Protocol: MCP {actual_protocol_version}
Module: {module_name}
Tool: {original_name}
"""

from typing import Annotated, Literal, Any, Dict
from pydantic import BaseModel, Field
import anyio

{model_code}

async def call(
    base_url: str,
    params: 'Params',
    *,
    headers: Dict[str, str] | None = None
) -> Any:
    """Call the {original_name} tool.

    Args:
        base_url: MCP server base URL
        params: Tool parameters
        headers: Optional HTTP headers

    Returns:
        Tool result
    """
    # Import at call time to avoid circular imports
    from mcp_codegen.runtime.client import Client

    async with Client(base_url, headers=headers) as client:
        arguments = params.model_dump(mode="json", exclude_none=True)
        result = await client.call_tool({original_name!r}, arguments)
        return result

def call_sync(
    base_url: str,
    params: 'Params',
    *,
    headers: Dict[str, str] | None = None
) -> Any:
    """Synchronous wrapper for call().

    Args:
        base_url: MCP server base URL
        params: Tool parameters
        headers: Optional HTTP headers

    Returns:
        Tool result
    """
    return anyio.run(call, base_url, params, headers=headers)
'''

        # Write tool file
        tool_file_path = server_dir / f"{tool_name}.py"
        tool_file_path.write_text(tool_file_content, encoding="utf-8")

        # Collect info for __init__.py
        tool_info.append({
            "name": tool_name,
            "original_name": original_name,
            "description": getattr(tool, 'description', '')
        })

    # Generate __init__.py with index
    init_content = f'''"""MCP Server: {module_name}

Auto-generated index for server: {base_url}
Protocol: MCP {actual_protocol_version}

This module provides progressive disclosure - you can import individual tools:
    from servers.{module_name}.{tool_info[0]["name"] if tool_info else "tool"} import call, Params

Or search for tools:
    from mcp_codegen.runtime import search_tools
    tools = search_tools("query", servers_dir="servers")
"""

from __future__ import annotations

# Server metadata
SERVER_NAME = {module_name!r}
SERVER_URL = {base_url!r}
SERVER_TOOLS = {tool_info}

# Re-export all tools
'''

    # Add re-exports
    for info in tool_info:
        init_content += f"from .{info['name']} import call as {info['name']}, call_sync as {info['name']}_sync, Params as {info['name'].title()}Params\n"

    init_content += "\n__all__ = [\n"
    for info in tool_info:
        init_content += f"    '{info['name']}',\n"
        init_content += f"    '{info['name']}_sync',\n"
        init_content += f"    '{info['name'].title()}Params',\n"
    init_content += "]\n"

    # Write __init__.py
    init_file_path = server_dir / "__init__.py"
    init_file_path.write_text(init_content, encoding="utf-8")

    print(f"✓ Generated filesystem layout → {server_dir}/")
    print(f"  {len(tool_info)} tool(s) in {len(list(server_dir.glob('*.py')))} files")
